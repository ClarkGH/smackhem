---
name: Sun/Moon Lighting Cycle (Consolidated)
overview: Consolidate all sun/moon lighting cycle plans into a single implementation plan that includes physical sun/moon rules using spherical coordinates (azimuth/elevation), deterministic lighting calculations with improved curves (sigmoid ambient, color gradients), and sphere-rendered celestial objects (orbs) positioned at infinite distance with depth override, using specific colors (golden yellow sun, cool blue moon). All calculations use fixed timestep for perfect determinism.
todos:
  - id: track_simulation_time
    content: Add simulationTime tracking in gameLoop (initialize to 0, increment in updateSimulation with FIXED_DT)
    status: pending
  - id: create_lighting_functions
    content: "Create helper functions using spherical coordinates: getTimeOfDay, computeSunSpherical (azimuth/elevation), sphericalToDirection, computeSunDirection (converts spherical to Cartesian), computeLightColor (elevation-based gradient with atmospheric scattering), computeAmbientIntensity (sigmoid curve using cos^4). Define HORIZON_THRESHOLD and DECLINATION_OFFSET constants. Use zero-allocation design (write into pre-allocated objects)"
    status: pending
  - id: extend_renderer_interface
    content: Add setLightColor? and setAmbientIntensity? optional methods to Renderer interface (setLightDirection already exists)
    status: pending
  - id: update_render_function
    content: "Replace hardcoded lighting in render() with deterministic calculations: compute spherical coordinates (azimuth/elevation), convert to direction, compute elevation-based color gradient and sigmoid ambient intensity, call all three renderer setters. Use pre-allocated objects with out-parameter pattern (zero allocations)"
    status: pending
    dependencies:
      - track_simulation_time
      - create_lighting_functions
      - extend_renderer_interface
  - id: implement_webgl_setters
    content: Implement setLightColor and setAmbientIntensity methods in WebGLRenderer (store in existing private fields)
    status: pending
    dependencies:
      - extend_renderer_interface
  - id: update_design_document
    content: Update DESIGN.md section 6.4 with physical sun/moon rules, implemented architecture details, formulas, and coordinate system specifications
    status: pending
    dependencies:
      - create_lighting_functions
  - id: define_celestial_constants
    content: "Define CELESTIAL_DISTANCE (9999.0 or camera.far - 1.0 for infinite distance), SUN_SIZE (0.5), MOON_SIZE (0.4), SUN_COLOR (golden yellow: 1.0, 0.85, 0.2), MOON_COLOR (cool blue: 0.4, 0.6, 0.9) in gameLoop closure"
    status: pending
  - id: create_visibility_functions
    content: Create computeSunVisibility and computeMoonVisibility functions that return 0-1 fade values based on timeOfDay
    status: pending
  - id: create_position_function
    content: "Create computeCelestialPosition function using out-parameter pattern: position = playerPosition + lightDirection * distance"
    status: pending
  - id: create_celestial_transform
    content: "Create computeCelestialTransform function: builds simple translation matrix for sphere positioning. Write translation matrix directly into output Mat4 (zero allocation). Spheres are orbs so they look correct from any angle without rotation"
    status: pending
  - id: implement_infinite_distance
    content: Update CELESTIAL_DISTANCE to very large value (9999.0 or camera.far - 1.0) for infinite distance rendering. Optionally implement drawMeshWithDepthOverride in renderer for depth testing override
    status: pending
  - id: create_celestial_meshes
    content: Create sunMesh and moonMesh using createSphereMesh (orbs) once in gameLoop closure, store as constants. Use appropriate radius for each (SUN_SIZE and MOON_SIZE)
    status: pending
  - id: preallocate_celestial_objects
    content: Pre-allocate sunPosition, moonPosition, sunTransform, moonTransform, moonLightDirection objects in gameLoop closure
    status: pending
  - id: compute_moon_direction
    content: In render(), compute moon spherical coordinates (azimuth = sunAzimuth + π, elevation = -sunElevation), then convert to direction using sphericalToDirection
    status: pending
  - id: calculate_celestial_positions
    content: In render(), compute spherical coordinates for sun and moon, convert to directions, call computeCelestialPosition for both, then computeCelestialTransform (simple translation) for both
    status: pending
    dependencies:
      - create_position_function
      - create_celestial_transform
      - preallocate_celestial_objects
      - compute_moon_direction
  - id: render_celestial_objects
    content: In render(), calculate visibility, apply to colors, compute MVP matrices, and call drawMesh for sun and moon (only if visibility > 0)
    status: pending
    dependencies:
      - create_visibility_functions
      - create_celestial_meshes
      - calculate_celestial_positions
  - id: optimize_color_allocations
    content: Pre-allocate sunColorWithVisibility and moonColorWithVisibility objects, update rendering code to write into them instead of creating new objects
    status: pending
    dependencies:
      - render_celestial_objects
  - id: add_debug_hud
    content: Add toggleable debug HUD showing sun/moon positions, camera position, and facing direction in red text (2D canvas overlay)
    status: pending
    dependencies:
      - track_simulation_time
      - create_lighting_functions
---

# Sun/Moon Lighting Cycle Implementation (

Consolidated)

## Overview

Implement a deterministic sun/moon lighting cycle that:

1. Rotates light direction following physical sun/moon rules (east → overhead → west → below horizon)
2. Changes light color from warm (day) to cool (night)
3. Adjusts ambient intensity (bright day to dark night)
4. Renders physical visual sky objects (sphere sun, sphere moon) positioned at infinite distance, using specific colors (golden yellow sun, cool blue moon)
5. All based on simulation time (deterministic, platform-agnostic)

This fixes the current violation where lighting is hardcoded in `gameLoop.ts` and implements proper physical astronomical behavior.

## Architecture

Lighting parameters are computed in core as pure functions of simulation time and passed to the renderer via service interface methods. The implementation follows DESIGN.md section 6.4 and RULE R-3 exception.

```mermaid
graph TD
    A[gameLoop.updateSimulation] -->|Accumulate FIXED_DT| B[simulationTime]
    C[gameLoop.render] -->|Read simulationTime| D[computeLightingParams]
    D -->|getTimeOfDay| E[timeOfDay 0-1]
    E -->|computeSunDirection| F[lightDirection Vec3]
    E -->|computeLightColor| G[lightColor Vec3]
    E -->|computeAmbientIntensity| H[ambientIntensity number]
    F -->|setLightDirection| I[Renderer Interface]
    G -->|setLightColor| I
    H -->|setAmbientIntensity| I
    I -->|Store values| J[WebGLRenderer]
    J -->|Use in shader uniforms| K[Shader Lighting]
    D -->|Compute positions| L[computeCelestialObjects]
    L -->|drawMesh sun/moon| I
```



## Physical Sun/Moon Rules

**Sun Arc:**

- Rises in the east (horizon) at dawn (timeOfDay ≈ 0.25)
- Reaches zenith (overhead) at noon (timeOfDay = 0.5)
- Sets in the west (horizon) at dusk (timeOfDay ≈ 0.75)
- Goes below horizon at night (timeOfDay 0.0-0.25, 0.75-1.0)

**Moon Arc:**

- Opposite phase to sun
- Visible during night (timeOfDay 0.0-0.25, 0.75-1.0)
- Follows opposite path across sky

**Coordinate System:**

- Y-up world space convention
- Light direction points FROM light source TOWARD scene
- Normalized 3D vectors in world space
- **Spherical Coordinates:** Use azimuth (compass direction) and elevation (height above horizon) for realistic celestial trajectories
- **Horizon Threshold:** Explicitly defined at elevation = 0. When elevation < 0, celestial body is "set" and transitions to night lighting

## Implementation Steps

### 1. Track Simulation Time and Pre-allocate Objects

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)

- Add `let simulationTime = 0;` in the gameLoop closure (initialized to 0, separate from frame accumulator)
- In `updateSimulation(dt: number)`, increment `simulationTime += dt;` (dt is FIXED_DT, ensuring deterministic accumulation)
- Simulation time never resets, allowing continuous day/night cycles
- This is the single source of truth for time-based effects per RULE T-3

**Performance Optimization:** Pre-allocate reusable Vec3 objects to avoid allocations in render loop (complies with RULE M-1):

```typescript
// Pre-allocate objects once in gameLoop closure (reused every frame)
const lightDirection = { x: 0, y: 0, z: 0 };
const lightColor = { x: 0, y: 0, z: 0 };
```



### 2. Create Lighting Calculation Functions with Spherical Coordinates (Zero-Allocation)

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts) (or new file [`src/core/lighting.ts`](src/core/lighting.ts) if it gets large)**Learning Note:** We use spherical coordinates (azimuth and elevation) instead of simple 2D rotations for more realistic celestial trajectories. This allows proper rising/setting behavior and supports future seasonal variations.Add helper functions that write into pre-allocated objects (zero allocations per frame, complies with RULE M-1):

```typescript
// Constants
const DAY_LENGTH_SECONDS = 120; // 2 minutes per full cycle (configurable)
const HORIZON_THRESHOLD = 0.0; // Elevation threshold for horizon (radians)
const DECLINATION_OFFSET = 0.0; // Seasonal tilt offset (for future use, currently 0)

// Convert simulation time to time of day (0-1 cycle)
// 0.0 = midnight, 0.25 = dawn, 0.5 = noon, 0.75 = dusk, 1.0 = next midnight
const getTimeOfDay = (simulationTime: number): number => {
    return (simulationTime % DAY_LENGTH_SECONDS) / DAY_LENGTH_SECONDS;
};

// Compute sun azimuth and elevation using spherical coordinates
// Azimuth: 0 = north, π/2 = east, π = south, 3π/2 = west (compass direction)
// Elevation: 0 = horizon, π/2 = zenith (height above horizon)
// PERFORMANCE: Writes into existing objects to avoid allocation
const computeSunSpherical = (
    timeOfDay: number,
    outAzimuth: { value: number },
    outElevation: { value: number },
): void => {
    // Map time of day to full rotation (0 to 2π)
    // Sun rises in east (π/2) at dawn (0.25), sets in west (3π/2) at dusk (0.75)
    const angle = timeOfDay * Math.PI * 2;
    
    // Elevation: sin curve from -1 (midnight) to 1 (noon) to -1 (next midnight)
    // Add declination offset for seasonal variation (future use)
    let elevation = Math.sin(angle) + DECLINATION_OFFSET;
    
    // Azimuth: cos curve, adjusted for east-west arc
    // At noon (0.5), azimuth = π (south)
    // At dawn (0.25), azimuth = π/2 (east)
    // At dusk (0.75), azimuth = 3π/2 (west)
    const azimuth = Math.PI / 2 + angle; // Start at east (π/2), rotate clockwise
    
    outAzimuth.value = azimuth;
    outElevation.value = elevation;
};

// Convert spherical coordinates (azimuth, elevation) to Cartesian direction vector
// PERFORMANCE: Writes into existing object to avoid allocation
const sphericalToDirection = (
    azimuth: number,
    elevation: number,
    out: Vec3,
): void => {
    // Spherical to Cartesian conversion:
    // x = cos(elevation) * sin(azimuth)  [east-west component]
    // y = sin(elevation)                [up-down component]
    // z = cos(elevation) * cos(azimuth) [north-south component]
    
    const cosElev = Math.cos(elevation);
    out.x = cosElev * Math.sin(azimuth);
    out.y = Math.sin(elevation);
    out.z = cosElev * Math.cos(azimuth);
    
    // Normalize (should already be normalized, but safety check)
    const len = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
    if (len > 0.0001) {
        out.x /= len;
        out.y /= len;
        out.z /= len;
    }
};

// Compute sun direction using spherical coordinates
// Physical behavior: east → overhead → west → below horizon
// Coordinate system: Y-up world space, light direction points FROM light source TOWARD scene
// PERFORMANCE: Writes into existing object to avoid allocation
const computeSunDirection = (timeOfDay: number, out: Vec3): void => {
    const azimuth = { value: 0 };
    const elevation = { value: 0 };
    
    // Compute spherical coordinates
    computeSunSpherical(timeOfDay, azimuth, elevation);
    
    // Convert to Cartesian direction
    sphericalToDirection(azimuth.value, elevation.value, out);
    
    // Clamp elevation to horizon: if below horizon, use horizontal light
    // This prevents lighting from below the floor
    if (elevation.value < HORIZON_THRESHOLD) {
        // Use horizontal direction (Y = 0) when below horizon
        const len = Math.sqrt(out.x * out.x + out.z * out.z);
        if (len > 0.0001) {
            out.x /= len;
            out.y = 0;
            out.z /= len;
        } else {
            out.x = 0;
            out.y = 0;
            out.z = -1; // Default: north
        }
    }
};

// Compute light color with elevation-based gradient
// Color transitions: white at zenith → red/orange near horizon → cool at night
// Simulates atmospheric scattering (Rayleigh scattering)
// PERFORMANCE: Writes into existing object to avoid allocation
const computeLightColor = (
    timeOfDay: number,
    elevation: number,
    out: Vec3,
): void => {
    // Normalize elevation to 0-1 range (horizon to zenith)
    const normalizedElev = Math.max(0, Math.min(1, (elevation + 1) / 2));
    
    if (elevation < HORIZON_THRESHOLD) {
        // Below horizon: cool night color
        out.x = 0.3;
        out.y = 0.4;
        out.z = 0.6; // Cool blue
    } else {
        // Above horizon: gradient from white (zenith) to red/orange (horizon)
        // Use smoothstep for smooth transition
        const t = normalizedElev;
        const smoothT = t * t * (3 - 2 * t); // Smoothstep function
        
        // White at zenith, red/orange at horizon
        out.x = 0.8 + 0.2 * smoothT; // Red component: 1.0 at zenith, 0.8 at horizon
        out.y = 0.7 + 0.3 * smoothT; // Green component: 1.0 at zenith, 0.7 at horizon
        out.z = 0.5 + 0.5 * smoothT; // Blue component: 1.0 at zenith, 0.5 at horizon (warmer)
    }
};

// Compute ambient intensity using sigmoid curve (sharp drop near horizon)
// Uses high-power cosine for sharp transition, not linear fade
// PERFORMANCE: Pure function, no allocations
const computeAmbientIntensity = (elevation: number): number => {
    if (elevation < HORIZON_THRESHOLD) {
        return 0.1; // Dark night ambient
    }
    
    // Normalize elevation to 0-1 (horizon to zenith)
    const normalizedElev = (elevation + 1) / 2;
    
    // Use high-power cosine for sharp drop near horizon
    // cos^4 curve: drops sharply near 0, stays high near 1
    const cosElev = Math.cos(normalizedElev * Math.PI / 2);
    const intensity = cosElev * cosElev * cosElev * cosElev; // cos^4
    
    // Map to ambient range: 0.1 (horizon) to 0.5 (zenith)
    return 0.1 + 0.4 * intensity;
};
```

**Key Details:**

- All functions are pure (no side effects, deterministic)
- Based solely on simulation time (no platform dependencies)
- **Zero allocations:** Functions write into pre-allocated objects instead of creating new ones
- Coordinate system: Y-up world space, light direction normalized vector
- Sun/moon transition: Single directional light represents sun during day (0.0-0.5) and moon during night (0.5-1.0)
- Smooth sinusoidal interpolation for natural transitions
- Physical behavior: Sun arc from east → overhead → west → below horizon
- **Horizon clamping:** Sun height is clamped to `Math.max(0, sunHeight)` to prevent lighting from below the floor
- Inline normalization avoids calling `normalizeVec3()` which would allocate

### 3. Extend Renderer Interface

**File:** [`src/services/renderer.ts`](src/services/renderer.ts)Add optional methods to the `Renderer` interface (matching DESIGN.md section 6.4):

```typescript
export interface Renderer {
    // ... existing methods ...
    setLightDirection?(_direction: Vec3): void; // Already exists
    setLightColor?(_color: Vec3): void; // ADD THIS
    setAmbientIntensity?(_intensity: number): void; // ADD THIS
}
```

**Note:** `setLightDirection` already exists in the interface but is not being used correctly (hardcoded value in gameLoop). All three methods should be optional to support stub renderers.

### 4. Update Game Loop Render Function

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)In the `render()` function, replace the hardcoded lighting (lines 91-94) with deterministic calculations:**Remove:**

```typescript
// Keep everything in world space (model transforms are translation-only)
// Using a more angled direction to make lighting direction more obvious
const lightDirection = normalizeVec3({ x: -0.707, y: 0.5, z: -0.5 });
if (renderer.setLightDirection) {
    renderer.setLightDirection(lightDirection);
}
```

**Note:** The current hardcoded lighting violates RULE M-1 because:

- `{ x: -0.707, y: 0.5, z: -0.5 }` creates a new object literal every frame
- `normalizeVec3()` returns a new Vec3 object every frame
- This causes 2 allocations per frame in the render loop

**Replace with:**

```typescript
// Compute lighting parameters deterministically from simulation time
// PERFORMANCE: Reuse pre-allocated objects, zero allocations per frame
const timeOfDay = getTimeOfDay(simulationTime);

// Compute spherical coordinates (azimuth, elevation)
const sunAzimuth = { value: 0 };
const sunElevation = { value: 0 };
computeSunSpherical(timeOfDay, sunAzimuth, sunElevation);

// Compute sun direction from spherical coordinates
computeSunDirection(timeOfDay, lightDirection);

// Compute light color based on elevation (gradient with atmospheric scattering)
computeLightColor(timeOfDay, sunElevation.value, lightColor);

// Compute ambient intensity using sigmoid curve (sharp drop near horizon)
const ambientIntensity = computeAmbientIntensity(sunElevation.value);

// Set lighting parameters via renderer interface
if (renderer.setLightDirection) {
    renderer.setLightDirection(lightDirection);
}
if (renderer.setLightColor) {
    renderer.setLightColor(lightColor);
}
if (renderer.setAmbientIntensity) {
    renderer.setAmbientIntensity(ambientIntensity);
}
```

**Key Points:**

- Calculations occur in render function (deterministic, no simulation side effects per DESIGN.md)
- All values computed fresh each frame (pure functions, no caching needed)
- Uses accumulated simulation time, not frame rate or platform timing
- **Zero allocations:** Pre-allocated objects are reused, no object creation in render loop (complies with RULE M-1)

### 5. Implement WebGL Renderer Setters

**File:** [`src/platforms/web/webGLRenderer.ts`](src/platforms/web/webGLRenderer.ts)Add the setter methods to store lighting parameters:

```typescript
setLightColor(color: Vec3): void {
    this.lightColor = color;
}

setAmbientIntensity(intensity: number): void {
    this.ambientIntensity = intensity;
}
```

**Note:**

- `setLightDirection` already exists (line 518)
- `this.lightColor` and `this.ambientIntensity` already exist as private fields (lines 25, 27)
- These values are already used in shader uniforms in `drawMesh()` (lines 487-496)
- No shader changes needed, just wire up the setters

### 6. Update Design Document

**File:** [`DESIGN.md`](DESIGN.md)Update section 6.4 "Day/Night Lighting Cycle" with the implemented architecture details:**Add/Update the following sections:**

1. **Physical Sun/Moon Rules:**

- Sun arc: from horizon (east) → overhead (noon) → horizon (west) → below horizon (night)
- Moon arc: opposite phase (visible during night)
- Coordinate system: Y-up world space, normalized vectors

2. **Exact Formulas Section:**

- Document the exact formulas for `computeSunDirection`, `computeLightColor`, and `computeAmbientIntensity`
- Include the `DAY_LENGTH_SECONDS` constant value (120 seconds)
- Specify the coordinate system (Y-up world space, normalized vectors)

3. **Implementation Details:**

- Clarify that simulation time is tracked separately from frame accumulator
- Document that calculations occur in render function (not simulation)
- Specify that all functions are pure (no side effects, deterministic)

4. **Time Mapping:**

- Time 0 = midnight (moon visible)
- Time 0.25 = dawn (sun rising in east)
- Time 0.5 = noon (sun overhead)
- Time 0.75 = dusk (sun setting in west)

**Location:** Update existing section 6.4, adding concrete implementation details while maintaining the high-level architecture description.

## Physical Sun/Moon Visual Representation (Refined)

This section implements physical representations of the sun and moon as orbs (spheres) positioned at infinite distance with depth override. Spheres look correct from any viewing angle and provide a natural celestial appearance.

### 7. Define Celestial Object Constants and Colors

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Constants are defined at the top of the closure so they're accessible to all functions and clearly visible. Colors are defined as RGB values (0-1 range, matching our Vec3 color system).Add constants for celestial objects:

```typescript
// Constants for visual celestial objects
const CELESTIAL_DISTANCE = 9999.0; // Very large distance (effectively infinite, must be < camera.far)
const SUN_SIZE = 0.5; // Radius of sun orb (sphere)
const MOON_SIZE = 0.4; // Radius of moon orb (sphere)

// Color definitions (RGB values 0-1)
// Golden yellow sun: warm, bright yellow-orange
const SUN_COLOR: Vec3 = { x: 1.0, y: 0.85, z: 0.2 }; // Golden yellow

// Cool blue moon: cool, desaturated blue
const MOON_COLOR: Vec3 = { x: 0.4, y: 0.6, z: 0.9 }; // Cool blue
```

**Why these values:**

- `CELESTIAL_DISTANCE = 9999.0`: Very large distance (effectively infinite) to avoid depth-sorting issues and prevent clipping through terrain
- `SUN_SIZE = 0.5`: Radius of sun orb - visible but not overwhelming
- `MOON_SIZE = 0.4`: Radius of moon orb - slightly smaller than sun for visual hierarchy
- Colors chosen to match the warm/cool lighting theme

### 8. Create Visibility Calculation Functions

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Visibility functions determine when objects should be visible based on time of day. They return 0-1 values for smooth fade transitions.Add functions to compute visibility (when sun/moon should be visible):

```typescript
// Compute sun visibility (0-1, smooth transition)
// Sun visible during day (0.25 to 0.75 of cycle), fade at edges
// PERFORMANCE: Pure function, no allocations
const computeSunVisibility = (timeOfDay: number): number => {
    const dayCenter = 0.5; // Noon is center of day
    const dayWidth = 0.5; // Day spans 0.25 to 0.75 (half the cycle)
    const dist = Math.abs(timeOfDay - dayCenter) * 2; // Distance from center, scaled
    return Math.max(0, 1 - (dist / dayWidth)); // Fade from 1 at center to 0 at edges
};

// Compute moon visibility (0-1, smooth transition)
// Moon visible during night (opposite of sun)
// PERFORMANCE: Pure function, no allocations
const computeMoonVisibility = (timeOfDay: number): number => {
    return 1 - computeSunVisibility(timeOfDay);
};
```

**How it works:**

- `computeSunVisibility`: Returns 1.0 at noon (0.5), fades to 0.0 at dawn/dusk (0.25/0.75)
- `computeMoonVisibility`: Inverse of sun visibility (visible when sun is not)
- Smooth transitions prevent pop-in/pop-out artifacts

### 9. Create Position Calculation Function

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Position is calculated by starting at the camera position and moving along the light direction vector by the distance. This ensures the sun/moon always appear in the direction the light is coming from.Add function to compute celestial object position:

```typescript
// Compute sun/moon position in world space (along light direction, at fixed distance from player)
// PERFORMANCE: Writes into existing object to avoid allocation (complies with RULE M-1)
// LEARNING: Vector math: position = start + direction * distance
const computeCelestialPosition = (
    lightDirection: Vec3,  // Normalized direction vector (points FROM light TOWARD scene)
    distance: number,       // Distance from player to celestial object
    playerPosition: Vec3,  // Player/camera position in world space
    out: Vec3,             // Output: celestial object position
): void => {
    // Position = player position + (light direction * distance)
    // Note: lightDirection points TOWARD scene, so we use it directly
    out.x = playerPosition.x + lightDirection.x * distance;
    out.y = playerPosition.y + lightDirection.y * distance;
    out.z = playerPosition.z + lightDirection.z * distance;
};
```

**Vector Math Explanation:**

- `lightDirection` is normalized (length = 1.0)
- Multiplying by `distance` scales the vector to the desired length
- Adding to `playerPosition` translates the vector to world space
- Result: celestial object is exactly `distance` units away in the light direction

### 10. Create Transform Matrix Calculation Function

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Transform matrices position objects in 3D space. We write directly into the matrix array to avoid allocations. The matrix includes translation (position) and will later include rotation to face the light direction.Add function to compute transform matrix (with rotation relative to lightDirection):

```typescript
// Compute transform matrix for celestial object
// Includes translation (position) and rotation to face light direction
// PERFORMANCE: Writes into existing matrix to avoid allocation
// LEARNING: 4x4 transformation matrix layout (column-major order)
const computeCelestialTransform = (
    position: Vec3,        // World position of celestial object
    lightDirection: Vec3,  // Direction to rotate object toward
    size: number,          // Size scaling factor (for future use)
    out: Mat4,            // Output: 4x4 transformation matrix
): void => {
    const o = out.elements;
    
    // For now, create identity matrix with translation
    // TODO: Add rotation to face lightDirection (see step 11)
    
    // Column 0: X-axis (right)
    o[0] = 1; o[1] = 0; o[2] = 0; o[3] = 0;
    // Column 1: Y-axis (up)
    o[4] = 0; o[5] = 1; o[6] = 0; o[7] = 0;
    // Column 2: Z-axis (forward)
    o[8] = 0; o[9] = 0; o[10] = 1; o[11] = 0;
    // Column 3: Translation (position)
    o[12] = position.x; o[13] = position.y; o[14] = position.z; o[15] = 1;
};
```

**Matrix Layout Explanation:**

- 4x4 matrices are stored as 16-element arrays in column-major order
- Columns 0-2: X, Y, Z axes (rotation/scaling)
- Column 3: Translation (position)
- Element [15] is always 1.0 for homogeneous coordinates

### 11. Add Rotation to Face Light Direction

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** To make objects rotate relative to lightDirection, we need to build a rotation matrix. The object's forward axis should point in the opposite direction of lightDirection (since lightDirection points TOWARD scene, object should face AWAY from scene toward the light source).Update `computeCelestialTransform` to include rotation:

```typescript
// Compute transform matrix for celestial object with rotation
// Object's forward axis points opposite to lightDirection (toward light source)
// PERFORMANCE: Writes into existing matrix to avoid allocation
const computeCelestialTransform = (
    position: Vec3,        // World position of celestial object
    lightDirection: Vec3,  // Direction to rotate object toward
    size: number,          // Size scaling factor
    out: Mat4,            // Output: 4x4 transformation matrix
): void => {
    const o = out.elements;
    
    // Object should face opposite to lightDirection (toward light source)
    // lightDirection points FROM light TOWARD scene, so object forward = -lightDirection
    const forward = { 
        x: -lightDirection.x, 
        y: -lightDirection.y, 
        z: -lightDirection.z 
    };
    
    // Build orthonormal basis: forward, right, up
    // Right = forward × world-up (Y-axis)
    const worldUp = { x: 0, y: 1, z: 0 };
    const right = {
        x: forward.y * worldUp.z - forward.z * worldUp.y,
        y: forward.z * worldUp.x - forward.x * worldUp.z,
        z: forward.x * worldUp.y - forward.y * worldUp.x,
    };
    
    // Normalize right vector
    const rightLen = Math.sqrt(right.x * right.x + right.y * right.y + right.z * right.z);
    if (rightLen > 0.0001) {
        right.x /= rightLen;
        right.y /= rightLen;
        right.z /= rightLen;
    }
    
    // Up = right × forward (re-orthogonalize)
    const up = {
        x: right.y * forward.z - right.z * forward.y,
        y: right.z * forward.x - right.x * forward.z,
        z: right.x * forward.y - right.y * forward.x,
    };
    
    // Normalize up vector
    const upLen = Math.sqrt(up.x * up.x + up.y * up.y + up.z * up.z);
    if (upLen > 0.0001) {
        up.x /= upLen;
        up.y /= upLen;
        up.z /= upLen;
    }
    
    // Write rotation matrix (columns 0-2) and translation (column 3)
    // Column 0: Right axis
    o[0] = right.x; o[1] = right.y; o[2] = right.z; o[3] = 0;
    // Column 1: Up axis
    o[4] = up.x; o[5] = up.y; o[6] = up.z; o[7] = 0;
    // Column 2: Forward axis (negated lightDirection)
    o[8] = forward.x; o[9] = forward.y; o[10] = forward.z; o[11] = 0;
    // Column 3: Translation
    o[12] = position.x; o[13] = position.y; o[14] = position.z; o[15] = 1;
    
    // Apply size scaling to rotation axes (if needed)
    if (size !== 1.0) {
        o[0] *= size; o[1] *= size; o[2] *= size;  // Right
        o[4] *= size; o[5] *= size; o[6] *= size;  // Up
        o[8] *= size; o[9] *= size; o[10] *= size; // Forward
    }
};
```

**Rotation Math Explanation:**

- **Cross Product:** Used to build perpendicular vectors (right = forward × up)
- **Orthonormal Basis:** Three perpendicular, normalized vectors define object orientation
- **Forward = -lightDirection:** Object faces toward light source (opposite of light direction)
- **Right and Up:** Built using cross products to ensure perpendicularity

### 12. Create Sun and Moon Mesh Handles (Orbs)

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Meshes are created once in the closure and reused every frame. This avoids recreating geometry data repeatedly. Both sun and moon use sphere meshes (orbs) which look correct from any viewing angle.Create mesh handles once in the gameLoop closure:

```typescript
// Create meshes once (reused every frame)
// Sun: sphere mesh (orb)
const sunMesh = renderer.createSphereMesh(SUN_SIZE, 16); // 16 segments for smooth sphere

// Moon: sphere mesh (orb)
const moonMesh = renderer.createSphereMesh(MOON_SIZE, 16); // 16 segments for smooth sphere
```

**Why sphere meshes:**

- `createSphereMesh`: Creates a sphere (orb) which looks correct from any viewing angle
- Spheres are naturally suited for celestial objects (sun and moon appear as orbs in the sky)
- Both meshes are cached by the renderer (see `webGLRenderer.ts` meshCache), so creating them is cheap
- 16 segments provides a good balance between visual quality and performance

### 13. Pre-allocate Objects for Celestial Rendering

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Pre-allocating objects in the closure avoids allocations in the render loop (complies with RULE M-1). These objects are reused every frame.Add pre-allocated objects in the gameLoop closure (after mesh creation):

```typescript
// Pre-allocate objects for celestial rendering (zero allocations per frame)
const sunPosition = { x: 0, y: 0, z: 0 };
const moonPosition = { x: 0, y: 0, z: 0 };
const sunTransform = identity(); // 4x4 matrix
const moonTransform = identity(); // 4x4 matrix
const moonLightDirection = { x: 0, y: 0, z: 0 }; // For moon (opposite of sun)
```

**Why pre-allocate:**

- `identity()` creates a matrix once (outside render loop)
- Vec3 objects are reused, not recreated
- All calculations write into these existing objects

### 14. Compute Moon Light Direction (Opposite of Sun)

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** The moon follows the opposite path of the sun. We compute its direction by inverting the sun's light direction.In the `render()` function, after computing sun direction, compute moon direction:

```typescript
// Moon direction is opposite of sun direction (opposite phase)
// PERFORMANCE: Writes into pre-allocated object
moonLightDirection.x = -lightDirection.x;
moonLightDirection.y = -lightDirection.y;
moonLightDirection.z = -lightDirection.z;
```

**Why opposite:**

- Moon is visible when sun is not (night vs day)
- Moon follows opposite arc across sky
- Inverting the direction vector creates the opposite path

### 15. Calculate Celestial Positions and Transforms

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Positions are calculated relative to the player, and transforms include both position and rotation. We use the out-parameter pattern to avoid allocations.In the `render()` function, after computing lighting parameters, calculate celestial positions:

```typescript
// Compute sun position (along light direction, 40 units from player)
computeCelestialPosition(lightDirection, CELESTIAL_DISTANCE, camera.position, sunPosition);

// Compute moon position (along opposite direction, 40 units from player)
computeCelestialPosition(moonLightDirection, CELESTIAL_DISTANCE, camera.position, moonPosition);

// Compute transforms (simple translation + scaling for spheres)
computeCelestialTransform(sunPosition, SUN_SIZE, sunTransform);
computeCelestialTransform(moonPosition, MOON_SIZE, moonTransform);
```

**Execution Order:**

1. Calculate positions first (needed for transforms)
2. Calculate transforms (includes rotation based on light direction)
3. Both use out-parameter pattern (zero allocations)

### 16. Calculate Visibility and Render Celestial Objects

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Visibility determines when objects should be drawn. We multiply the color by visibility to fade objects in/out smoothly. Objects are only rendered if visibility > 0.In the `render()` function, after calculating transforms, compute visibility and render:

```typescript
// Calculate visibility (0-1, smooth fade)
const sunVisibility = computeSunVisibility(timeOfDay);
const moonVisibility = computeMoonVisibility(timeOfDay);

// Render sun (if visible)
if (sunVisibility > 0) {
    // Apply visibility to color (fade in/out)
    const sunColorWithVisibility = {
        x: SUN_COLOR.x * sunVisibility,
        y: SUN_COLOR.y * sunVisibility,
        z: SUN_COLOR.z * sunVisibility,
    };
    
    // Calculate MVP matrix (model * view * projection)
    const sunMVP = matrixMultiply(viewProj, sunTransform);
    
    // Draw sun mesh
    renderer.drawMesh(sunMesh, sunMVP, sunColorWithVisibility);
}

// Render moon (if visible)
if (moonVisibility > 0) {
    // Apply visibility to color (fade in/out)
    const moonColorWithVisibility = {
        x: MOON_COLOR.x * moonVisibility,
        y: MOON_COLOR.y * moonVisibility,
        z: MOON_COLOR.z * moonVisibility,
    };
    
    // Calculate MVP matrix (model * view * projection)
    const moonMVP = matrixMultiply(viewProj, moonTransform);
    
    // Draw moon mesh
    renderer.drawMesh(moonMesh, moonMVP, moonColorWithVisibility);
}
```

**Rendering Pipeline:**

1. **Visibility Check:** Only render if visibility > 0 (avoids unnecessary draw calls)
2. **Color Modulation:** Multiply base color by visibility for smooth fade
3. **MVP Matrix:** Transform from model space → world space → view space → screen space
4. **Draw Call:** Renderer draws the mesh with the transformed position and modulated color

**Performance Note:** The color objects (`sunColorWithVisibility`, `moonColorWithVisibility`) are created here, but this is acceptable because:

- They're only created when visibility > 0 (conditional)
- They're small objects (3 numbers)
- This is less critical than the hot render loop allocations we've eliminated

### 17. Optimize Color Calculations (Optional Performance Improvement)

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** We can pre-allocate color objects to eliminate the remaining allocations. This is optional but maintains zero-allocation design.Add pre-allocated color objects in the closure:

```typescript
// Pre-allocate color objects for celestial rendering
const sunColorWithVisibility = { x: 0, y: 0, z: 0 };
const moonColorWithVisibility = { x: 0, y: 0, z: 0 };
```

Update rendering code to write into pre-allocated objects:

```typescript
// Render sun (if visible)
if (sunVisibility > 0) {
    // Apply visibility to color (write into pre-allocated object)
    sunColorWithVisibility.x = SUN_COLOR.x * sunVisibility;
    sunColorWithVisibility.y = SUN_COLOR.y * sunVisibility;
    sunColorWithVisibility.z = SUN_COLOR.z * sunVisibility;
    
    const sunMVP = matrixMultiply(viewProj, sunTransform);
    renderer.drawMesh(sunMesh, sunMVP, sunColorWithVisibility);
}

// Render moon (if visible)
if (moonVisibility > 0) {
    // Apply visibility to color (write into pre-allocated object)
    moonColorWithVisibility.x = MOON_COLOR.x * moonVisibility;
    moonColorWithVisibility.y = MOON_COLOR.y * moonVisibility;
    moonColorWithVisibility.z = MOON_COLOR.z * moonVisibility;
    
    const moonMVP = matrixMultiply(viewProj, moonTransform);
    renderer.drawMesh(moonMesh, moonMVP, moonColorWithVisibility);
}
```

**Result:** Zero allocations in render loop, even for celestial objects.

## Advanced Refinements

### 22. Sphere Mesh Implementation (Already Available)

**File:** [`src/platforms/web/webGLRenderer.ts`](src/platforms/web/webGLRenderer.ts)**Learning Note:** The renderer already has `createSphereMesh()` method implemented. We just need to use it for creating sun and moon orbs. No additional implementation needed.**Existing Implementation:**

- `createSphereMesh(radius: number, segments: number = 16)` already exists
- Creates a sphere using latitude/longitude subdivision
- Returns a cached mesh handle
- 16 segments provides good visual quality with reasonable performance

**Why Spheres (Orbs):**

- Look correct from any viewing angle (rotationally symmetric)
- Natural appearance for celestial objects (sun and moon appear as orbs in the sky)
- No rotation needed - spheres are the same from all angles
- Simple transform (just translation + uniform scaling)

### 23. Implement Infinite Distance Rendering

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts) and [`src/platforms/web/webGLRenderer.ts`](src/platforms/web/webGLRenderer.ts)**Learning Note:** Celestial objects should be rendered at infinite distance to avoid depth-sorting issues and prevent them from clipping through terrain. We use depth testing override to treat them as being at the farthest possible distance.**Implementation Steps:**

1. **Update Celestial Position Calculation:**

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)

```typescript
// Constants for visual celestial objects
const CELESTIAL_DISTANCE = 9999.0; // Very large distance (effectively infinite)
// Or use camera.far - 1.0 to ensure it's always rendered
```



2. **Add Depth Override to Renderer Interface (Optional):**

**File:** [`src/services/renderer.ts`](src/services/renderer.ts)

```typescript
export interface Renderer {
    // ... existing methods ...
    drawMeshWithDepthOverride?(
        mesh: MeshHandle,
        transform: Mat4,
        color: Vec3,
        depthValue: number, // Depth value to use (0.0 = near, 1.0 = far)
    ): void;
}
```



3. **Implement Depth Override in WebGLRenderer:**

**File:** [`src/platforms/web/webGLRenderer.ts`](src/platforms/web/webGLRenderer.ts)

```typescript
drawMeshWithDepthOverride(
    mesh: MeshHandle,
    transform: Mat4,
    color: Vec3,
    depthValue: number,
): void {
    // Save current depth test state
    const wasDepthTestEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
    const oldDepthFunc = this.gl.getParameter(this.gl.DEPTH_FUNC);
    
    // Enable depth test and set to always pass
    this.gl.enable(this.gl.DEPTH_TEST);
    this.gl.depthFunc(this.gl.ALWAYS); // Always pass depth test
    
    // Draw mesh normally
    this.drawMesh(mesh, transform, color);
    
    // Restore depth test state
    this.gl.depthFunc(oldDepthFunc);
    if (!wasDepthTestEnabled) {
        this.gl.disable(this.gl.DEPTH_TEST);
    }
}
```

**Alternative (Simpler):** Instead of depth override, position celestial objects at `camera.far - 1.0` distance and render them after all other geometry but before the skybox (if any). This ensures they're always at the back.

### 24. Update Render Function to Use Spherical Coordinates and Spheres

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** We need to update the render function to:

1. Compute elevation for color/ambient calculations
2. Use sphere meshes (orbs) instead of pyramid/cube
3. Use simple transform (translation + scaling) since spheres don't need rotation

Update the render function:

```typescript
// In render(), after computing timeOfDay:
const timeOfDay = getTimeOfDay(simulationTime);

// Compute spherical coordinates
const sunAzimuth = { value: 0 };
const sunElevation = { value: 0 };
computeSunSpherical(timeOfDay, sunAzimuth, sunElevation);

// Compute sun direction from spherical coordinates
computeSunDirection(timeOfDay, lightDirection);

// Compute light color based on elevation (gradient)
computeLightColor(timeOfDay, sunElevation.value, lightColor);

// Compute ambient intensity using sigmoid curve
const ambientIntensity = computeAmbientIntensity(sunElevation.value);

// Set lighting parameters
if (renderer.setLightDirection) {
    renderer.setLightDirection(lightDirection);
}
if (renderer.setLightColor) {
    renderer.setLightColor(lightColor);
}
if (renderer.setAmbientIntensity) {
    renderer.setAmbientIntensity(ambientIntensity);
}

// Compute moon spherical coordinates (opposite phase)
const moonAzimuth = { value: sunAzimuth.value + Math.PI }; // Opposite direction
const moonElevation = { value: -sunElevation.value }; // Opposite elevation

// Convert moon spherical to direction
sphericalToDirection(moonAzimuth.value, moonElevation.value, moonLightDirection);

// Compute celestial positions (at infinite distance)
computeCelestialPosition(lightDirection, CELESTIAL_DISTANCE, camera.position, sunPosition);
computeCelestialPosition(moonLightDirection, CELESTIAL_DISTANCE, camera.position, moonPosition);

// Compute transforms (simple translation + scaling for spheres)
computeCelestialTransform(sunPosition, SUN_SIZE, sunTransform);
computeCelestialTransform(moonPosition, MOON_SIZE, moonTransform);

// Calculate visibility and render (same as before, but using sphere meshes)
// ... (visibility and rendering code from step 16)
```



### 25. Determinism Verification

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)**Learning Note:** Ensure perfect determinism by verifying:

1. Fixed timestep is used (FIXED_DT = 1/60)
2. No external clocks (Date.now(), performance.now())
3. Single source of truth (simulationTime)
4. All calculations are pure functions of simulationTime

**Verification Checklist:**

- ✅ `simulationTime` increments by `FIXED_DT` in `updateSimulation`
- ✅ All lighting calculations use `simulationTime`, not frame time
- ✅ No platform-specific timing functions in core layer
- ✅ All functions are pure (no side effects, deterministic)
- ✅ Spherical coordinate calculations are deterministic (trig functions are deterministic for fixed inputs)

## Design Constraint Compliance

- **RULE R-3 (Lighting Lives in Renderer):** Lighting parameters computed in core as pure functions, passed via service interface, renderer applies in shaders
- **RULE R-2 (Rendering Is Declarative):** Game code declares lighting intent via setters, renderer decides how to apply
- **RULE T-3 (Time-Based Effects Must Be Deterministic):** Based on accumulated simulation time (fixed timestep), reproducible across platforms
- **RULE T-2 (No Hidden Time Sources):** Uses simulation time from game loop, not `Date.now()` or `performance.now()`
- **Layer Boundaries:** Core logic in core layer, no platform dependencies, service interface in services layer
- **RULE M-1 (No Allocation in Hot Loops):** Zero allocations in render function - pre-allocated objects reused, functions write into existing objects instead of creating new ones

## Performance Considerations

### Zero-Allocation Design

The implementation follows RULE M-1 by eliminating all allocations in the render loop:

1. **Pre-allocated Objects:** All Vec3 and Mat4 objects are created once in the gameLoop closure and reused every frame
2. **Out-Parameter Pattern:** All calculation functions write into existing objects instead of returning new ones:

- `computeSunDirection(timeOfDay, out)` - writes into `out`
- `computeLightColor(timeOfDay, out)` - writes into `out`
- `computeCelestialPosition(direction, distance, cameraPos, out)` - writes into `out`
- `computeCelestialTransform(position, lightDirection, size, out)` - writes into `out`

3. **Inline Calculations:** All vector math and matrix operations are done inline to avoid helper function allocations
4. **Conditional Rendering:** Objects are only rendered when visible, avoiding unnecessary draw calls

### Known Issues Fixed

- **Horizon Clamping:** Added `sunHeight = Math.max(0, sunHeight)` to prevent lighting from below the floor
- **Visual Objects Allocation:** All celestial object calculations use out-parameter pattern
- **Position Calculation:** Fixed `computeCelestialPosition` to use out-parameter pattern instead of returning new object
- **Current Code Violation:** The hardcoded lighting in `gameLoop.ts` line 91 violates RULE M-1 by allocating 2 objects per frame (`{ x, y, z }` literal + `normalizeVec3()` return value)

## Optional: Debug HUD

A toggleable text HUD for debugging sun/moon positions, camera position, and facing direction.

### 18. Add Debug HUD Toggle to Input

**File:** [`src/services/input.ts`](src/services/input.ts)Add a toggle flag to `PlayerIntent`:

```typescript
export interface PlayerIntent {
    move: { x: number; y: number };
    look: { yaw: number; pitch: number };
    toggleCamera: boolean;
    toggleDebugHUD?: boolean; // ADD THIS
}
```

**File:** [`src/platforms/web/webInput.ts`](src/platforms/web/webInput.ts)Map a key (e.g., 'H' or 'F3') to toggle the debug HUD flag.

### 19. Create Debug HUD Renderer

**File:** [`src/platforms/web/webBootstrap.ts`](src/platforms/web/webBootstrap.ts) or new file [`src/platforms/web/debugHUD.ts`](src/platforms/web/debugHUD.ts)Create a debug HUD system that:

- Uses a 2D canvas overlay on top of the WebGL canvas
- Renders text in red color for readability
- Shows debug information when enabled

**Implementation Approach:**

1. **Create 2D Canvas Overlay:**
   ```typescript
            // In webBootstrap.ts or debugHUD.ts
            const createDebugHUD = (canvas: HTMLCanvasElement): {
                render: (info: DebugInfo) => void;
                toggle: () => void;
                isVisible: () => boolean;
            } => {
                // Create 2D canvas overlay positioned on top of WebGL canvas
                const overlay = document.createElement('canvas');
                overlay.style.position = 'absolute';
                overlay.style.left = '0';
                overlay.style.top = '0';
                overlay.style.pointerEvents = 'none'; // Don't block mouse input
                overlay.width = canvas.width;
                overlay.height = canvas.height;
                canvas.parentElement?.appendChild(overlay);
                
                const ctx = overlay.getContext('2d');
                let visible = false;
                
                return {
                    render: (info: DebugInfo) => {
                        if (!visible || !ctx) return;
                        ctx.clearRect(0, 0, overlay.width, overlay.height);
                        ctx.fillStyle = 'red';
                        ctx.font = '14px monospace';
                        // Render debug text...
                    },
                    toggle: () => { visible = !visible; },
                    isVisible: () => visible,
                };
            };
   ```




2. **Debug Info Structure:**
   ```typescript
            interface DebugInfo {
                cameraPosition: Vec3;
                cameraForward: Vec3;
                sunPosition?: Vec3;
                moonPosition?: Vec3;
                timeOfDay?: number;
            }
   ```




### 20. Integrate Debug HUD into Game Loop

**File:** [`src/core/gameLoop.ts`](src/core/gameLoop.ts)

1. Add debug HUD state tracking:
   ```typescript
            let debugHUDVisible = false;
   ```




2. In `updateSimulation`, check for toggle:
   ```typescript
            const intent = input.getIntent();
            if (intent.toggleDebugHUD) {
                debugHUDVisible = !debugHUDVisible;
            }
   ```




3. In `render()`, pass debug info to HUD renderer (if available):
   ```typescript
            // After computing lighting parameters
            if (debugHUDVisible && renderer.renderDebugHUD) {
                const cameraForward = getCameraForward(camera.yaw, camera.pitch);
                renderer.renderDebugHUD({
                    cameraPosition: camera.position,
                    cameraForward: cameraForward,
                    sunPosition: sunPosition, // If visual objects are enabled
                    moonPosition: moonPosition, // If visual objects are enabled
                    timeOfDay: timeOfDay,
                });
            }
   ```


**Alternative Approach (Simpler):** If we don't want to extend the renderer interface, we can pass the debug HUD renderer directly to the game loop:

```typescript
const createGameLoop = (
    renderer: Renderer,
    input: Input,
    world: World,
    getAspectRatio: () => number,
    debugHUD?: { render: (info: DebugInfo) => void; toggle: () => void }, // Optional
) => {
    // ... existing code ...
    
    // In render():
    if (debugHUD && debugHUDVisible) {
        const cameraForward = getCameraForward(camera.yaw, camera.pitch);
        debugHUD.render({
            cameraPosition: camera.position,
            cameraForward: cameraForward,
            sunPosition: sunPosition,
            moonPosition: moonPosition,
            timeOfDay: timeOfDay,
        });
    }
};
```



### 21. Format Debug Text Display

**Display Format:**

```javascript
Camera Position: (x, y, z)
Facing Direction: (x, y, z)
Sun Position: (x, y, z) [or "Below Horizon"]
Moon Position: (x, y, z) [or "Below Horizon"]
Time of Day: 0.XX (HH:MM)
```

**Text Formatting:**

- Use `toFixed(2)` for position coordinates